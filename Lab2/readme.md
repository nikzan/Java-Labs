# Лабораторная работа №2

## Содержание
1. [Структура проекта](#структура-проекта)
2. [Как работает основной код в Main](#как-работает-основной-код-в-main)
3. [Задача 1A (1.3) — Имена](#задача-1a-13--имена)
4. [Задача 1B (1.2) — Человек](#задача-1b-12--человек)
5. [Задача 2 — Сотрудники и отделы](#задача-2--сотрудники-и-отделы)
6. [Задача 3 (3.4) — Список сотрудников отдела](#задача-3-34--список-сотрудников-отдела)
7. [Задача 4 (4.4) — Перегрузка конструкторов Name2](#задача-4-44--перегрузка-конструкторов-name2)
8. [Задача 5 (5.1) — Пистолет](#задача-5-51--пистолет)
9. [Вспомогательные элементы](#вспомогательные-элементы)

## Структура проекта
Проект состоит из следующих классов:

- `Main` — главный класс с точкой входа программы, меню и демонстрациями
- `Name` — класс для представления ФИО в формате «Фамилия Имя Отчество»
- `Name2` — класс для представления имени в формате «Имя Отчество Фамилия» с перегрузкой конструкторов
- `Person` — класс для представления человека с именем и ростом (валидация диапазона)
- `Department` — класс для представления отдела (название, начальник, список сотрудников)
- `Employee` — класс для представления сотрудника (имя, ссылка на отдел)
- `Gun` — класс для представления пистолета с патронами
- `TestRunner` — набор автоматических тестов по всем задачам

## Как работает основной код в Main
Основной цикл приложения организует выбор задания, запуск демонстрации, и дальнейшее действие пользователя.

```java
// Псевдокод основной петли
boolean exit = false;
int choice = 2; // 2 — вернуться к выбору задания
int choiceTask = 1;

do {
    if (choice == 2) {
        // выбор темы/задачи для демонстрации
        choiceTask = inputChoice(1, 5, "тему: 1) Name 2) Person 3) Department/Employee 4) Name2 5) Gun");
    }

    switch (choiceTask) {
        case 1: // Демонстрация Name
        case 2: // Демонстрация Person
        case 3: // Демонстрация Department и Employee
        case 4: // Демонстрация Name2
        case 5: // Демонстрация Gun
    }

    System.out.println("Повторить? 1) Да 2) К выбору задания 3) Выход");
    choice = inputChoice(1, 3, "вариант");
    if (choice == 3) exit = true;
} while (!exit);
```

Особенности:
- Валидация пользовательского ввода централизована во вспомогательных методах (`inputChoice`, проверки строк/чисел)
- Бизнес-логика классов не зависит от консоли — удобно для тестирования и повторного использования
- Повторы и возвраты из меню реализованы без дублирования кода

## Задача 1A (1.3) — Имена

Реализация: класс `Name`.

### Назначение
Хранит части имени (фамилия, имя, отчество) и формирует строковое представление «Фамилия Имя Отчество», пропуская пустые/отсутствующие части без лишних пробелов.

### Конструкторы и свойства
- `Name(String lastName, String firstName, String patronymic)` — создаёт объект без дополнительной валидации (value object)
- Геттеры для каждой части имени предоставляют доступ, не навязывая формат вывода

### Особенности реализации
- Отсутствие полей допускается (null/пустые строки) — полезно при неполных данных
- Формирование строки аккуратно обрабатывает пробелы между заданными частями

**Примеры тестирования:**
```
- Name(null, "Клеопатра", null) -> Клеопатра
- Name("Пушкин", "Александр", "Сергеевич") -> Пушкин Александр Сергеевич
- Name("Маяковский", "Владимир", null) -> Маяковский Владимир
- Name("", "", "") -> (пустая строка)
```

## Задача 4 (4.4) — Перегрузка конструкторов Name2

Реализация: класс `Name2`.

### Назначение
Представляет имя в формате «Имя Отчество Фамилия». Поддерживает разные сценарии заполнения через перегрузку конструкторов.

### Конструкторы
- `Name2(String firstName)`
- `Name2(String firstName, String lastName)`
- `Name2(String firstName, String patronymic, String lastName)`

### Особенности реализации
- Перегрузка конструкторов избавляет от лишних параметров для частично заданных данных
- Строковое представление формируется из непустых частей в порядке: имя -> отчество -> фамилия

**Примеры тестирования:**
```
- Name2("Клеопатра") -> Клеопатра
- Name2("Александр", "Пушкин") -> Александр Пушкин
- Name2("Владимир", "Маяковский") -> Владимир Маяковский
- Name2("Христофор", "Бонифатьевич") -> Христофор Бонифатьевич
- Name2("Александр", "Сергеевич", "Пушкин") -> Александр Сергеевич Пушкин
```

## Задача 1B (1.2) — Человек

Реализация: класс `Person`.

### Назначение
Описывает человека с именем и ростом.

### Конструкторы и инварианты
- `Person(String name, int height)` — задаёт имя и рост
- Валидация на уровне сущности: рост строго в диапазоне 100–250 см; при нарушении выбрасывается `IllegalArgumentException`

### Особенности реализации
- Дублирующая проверка в UI повышает UX, но гарантия корректности — в самом классе
- Строковое представление: `Имя, рост: N`

**Примеры тестирования:**
```
- Person("Клеопатра", 152) -> Клеопатра, рост: 152
- Person("Пушкин", 167) -> Пушкин, рост: 167
- Person("Владимир", 189) -> Владимир, рост: 189
- Person("Минимум", 100) -> Минимум, рост: 100
- Person("Максимум", 250) -> Максимум, рост: 250
- Person("Ошибка", 99) -> ошибка (IllegalArgumentException)
- Person("Ошибка", 251) -> ошибка (IllegalArgumentException)
```

## Задача 2 — Сотрудники и отделы

Реализация: классы `Department` и `Employee`.

### Назначение
Модель отдела и его сотрудников. `Department` хранит название, начальника и список сотрудников. `Employee` связывает имя сотрудника с отделом.

### Архитектура и ключевые решения
- Двунаправленная связь: `Employee` хранит ссылку на `Department`, а `Department` — список сотрудников
- Роль начальника хранится в `Department` и учитывается при формировании описания сотрудника
- Инкапсуляция: `getEmployees()` возвращает копию списка (defensive copy), предотвращая внешнюю мутацию
- Человекочитаемые `toString()` учитывают случай «начальник не назначен»

### Типовые сценарии
- Добавление сотрудников в отдел (через `addEmployee` или конструктор сотрудника, который добавляет себя в отдел)
- Назначение начальника `setBoss(employee)`
- Получение списка сотрудников отдела `getEmployees()`

**Примеры тестирования:**
```
- Петров, Козлов, Сидоров работают в отделе IT
- Козлов назначен начальником отдела IT
- Вывод всех сотрудников:
    - Петров работает в отделе IT, начальник которого Козлов
    - Козлов начальник отдела IT
    - Сидоров работает в отделе IT, начальник которого Козлов
```

## Задача 3 (3.4) — Список сотрудников отдела

Реализация: метод `Department.getEmployees()`.

В `Department` реализован безопасный доступ к списку сотрудников: метод возвращает копию списка (defensive copy), защищая внутреннее состояние от внешних изменений. Пустой отдел корректно даёт пустой список.

**Примеры тестирования:**
```
- it.getEmployees() -> [Петров, Козлов, Сидоров]
- empty.getEmployees() -> []
```

## Задача 5 (5.1) — Пистолет

Реализация: класс `Gun`.

### Назначение
Пистолет с ограниченным количеством патронов. Поддерживает выстрелы и информирование при пустом магазине.

### Конструкторы
- `Gun()` — 5 патронов по умолчанию
- `Gun(int bullets)` — явное количество патронов

### Поведение
- `shoot()` — если патроны есть, печатает «Бах!» и уменьшает счётчик; иначе — «Клац!»
- `toString()` — «Пистолет с N патронами»

**Примеры тестирования:**
```
- Gun(3); пять выстрелов -> Бах! Бах! Бах! Клац! Клац!
- Gun() -> 5 патронов
- Gun(0) -> Клац!
- Gun(100) -> 100 патронов
```

## Вспомогательные элементы

### Ввод и валидация
В проекте используются вспомогательные методы (внутри `Main`) для безопасного ввода:
- Проверка диапазонов для числовых значений (например, меню 1..N)
- Запрет пустых строк там, где требуется значение
- Повтор запроса при ошибке с дружелюбными подсказками

### Автоматические тесты
`TestRunner` демонстрирует корректную работу всех классов, включая:
- Корректные и граничные случаи для `Person` (100/250 и вне диапазона)
- Формирование строк для `Name`/`Name2`
- Сценарии с отделами и начальником для `Department`/`Employee`
- Поведение `Gun` при наличии и отсутствии патронов
